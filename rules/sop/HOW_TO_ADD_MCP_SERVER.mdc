---
description: "Operational Protocol: Adding an MCP Server template. State-based guidance for helping users add new MCP server templates to the platform."
globs: []
alwaysApply: false
---

# Protocol: Add MCP Server

**Purpose:** Guide the user through adding a new MCP server template to the platform.

**Prerequisites:**
- User is on `/features` page or navigable to it
- User has identified a service they want to connect (e.g., "Salesforce", "Notion", "Vapi")

---

## âš ï¸ Critical: Element ID Rules

**NEVER guess or construct element IDs.** Always:

1. Look in the `elements` array from context for the exact `id` value
2. Use that `id` value exactly as provided
3. If an element is not in `elements`, it cannot be clicked

Common element IDs for this flow (always verify in context):
- Tab navigation: `mcp-modal-tab-add`, `mcp-modal-tab-variables`
- Detect variables: `detect-variables-btn`
- Submit server: `submit-server-btn`

---

## State Machine Overview

```
DISCOVERY â†’ SELECTION â†’ DOCS â†’ FORM_FILL â†’ DETECT_VARIABLES â†’ SAVE â†’ COMPLETE
    â†‘           â”‚        â”‚        â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜ (backtrack if missing info or user changes choice)
```

---

## Planning

When this SOP is loaded, your **next assistant message must include a plan** before any action.

### Plan format (JSON artifact)

Output your plan as a **single JSON object** in a `json` code block so it can be rendered and tracked by the UI. Keep it compact.

Required keys:
- `goal`
- `current_state` (use `page.full_path`, plus whether the template already exists in `data.servers`)
- `steps` (use the state names below, in order; each has a `status`)
- `decision_points` (where you must ask the user / wait)
- `verification` (what youâ€™ll confirm after key steps)

Allowed status values: `todo` | `doing` | `done` | `blocked`

After each completed state, update the same JSON (mark statuses and add brief notes). Do not create multiple competing plans.

Example:

```json
{
  "goal": "Add MCP server template for Notion",
  "current_state": {
    "page": "/features?action=add-server",
    "template_exists": false
  },
  "steps": [
    {"id": "DISCOVERY", "status": "doing"},
    {"id": "SELECTION", "status": "todo"},
    {"id": "DOCS", "status": "todo"},
    {"id": "FORM_FILL", "status": "todo"},
    {"id": "DETECT_VARIABLES", "status": "todo"},
    {"id": "SAVE", "status": "todo"},
    {"id": "COMPLETE", "status": "todo"}
  ],
  "decision_points": [
    "User must explicitly select an implementation in SELECTION"
  ],
  "verification": [
    "After SAVE, the new template appears in data.servers (or the UI shows a success state)"
  ]
}
```

---

## State: DISCOVERY

### Indicators
- On the add-server flow (`page.full_path`)
- No implementation selected yet
- Target service is known or needs clarification

### Context Check
- `page.full_path`
- `data.servers` (does a template already exist?)
- **Connected Integrations** (do you have a web-search MCP tool?)

### Goal
Produce 1-5 candidate implementations (GitHub repo and/or npm package) OR ask the user for a direct URL/package.

### Actions
1. If the target service is unclear, ask: â€œWhich service do you want to connect (e.g., Salesforce, Notion, Azure)?â€
2. If a template for this service already exists in `data.servers`, tell the user and ask whether they want to configure the existing template instead.
3. **Preferred search tool (deterministic):** If Connected Integrations includes `brave-search__brave_web_search`, use it for discovery. Do NOT â€œpick a search MCP serverâ€ opportunistically if Brave Search is available.

Example query (run 1-2 searches):

```
TOOL_CALL: {"name": "brave-search__brave_web_search", "parameters": {"query": "\"[SERVICE_NAME] MCP server\" site:github.com OR site:mcpservers.org OR site:npmjs.com"}}
```

4. **Fallback:** If Brave Search is NOT available, but `exa__web_search_exa` is available, use Exa.
   - If unsure of its parameters, call `get_mcp_tool_schema` once, then search with the same query intent.
5. If no web-search MCP tool is available:
   - Ask the user to provide a GitHub repo URL or npm package name for the MCP server implementation.

### Transitions
- Have â‰¥1 candidate â†’ **SELECTION**
- User provides a specific repo/package â†’ **DOCS**
- Waiting on user info â†’ stay in **DISCOVERY**

---

## State: SELECTION

### Indicators
- Candidate implementations are available
- User has not selected which implementation to use

### Goal
Present options and wait for explicit user selection.

### Actions
1. Present the candidates as a short table and include (optional) recommendation.

```markdown
ðŸ” **Found [N] MCP servers for [Service]:**

| # | Name | Stars | Updated | Install | Auth Type |
|---|------|-------|---------|---------|-----------|
| 1 | owner/repo-name | â­ 234 | 2024-11 | `npx` | API Key |
| 2 | owner/alternative | â­ 45 | 2024-10 | `uvx` | OAuth |

**My recommendation:** Option #1 (most popular, recently maintained, simpler auth)

Which would you like to install? (Reply with the number or name)
```

2. **STOP and wait**. Do not proceed without an explicit user selection.

### Transitions
- User selects an option â†’ **DOCS**
- User wants a different search / different options â†’ **DISCOVERY**
- User provides their own URL/package â†’ **DOCS**

---

## State: DOCS

### Indicators
- A specific implementation has been selected
- You still need the exact install/run command, args, and required variables

### Goal
Extract the exact information needed to build the server template form fields.

### Actions
1. Gather the implementation docs (README, install instructions, required env vars). Use a web-search MCP tool if available.
2. Extract this checklist:
   - Command + args (how the server is run)
   - Required variables (names + descriptions)
   - Which variables are secrets
   - OAuth: whether `oauth_enabled` should be true/false for this template
3. If any of the above is ambiguous, ask the user to confirm by pointing to the exact README section or pasting the relevant snippet.

### Transitions
- All required details gathered â†’ **FORM_FILL**
- Missing/ambiguous details â†’ wait for user input (stay in **DOCS**)
- User changes choice â†’ **SELECTION** (or **DISCOVERY**)

---

## State: FORM_FILL

### Indicators
- You have the selected implementationâ€™s run command/args and required variables
- The add-server form is present (`data.addServerForm`)

### Context Check
- `page.full_path` is `/features?action=add-server`
- `data.addServerForm` (current values + any validation errors)
- `actions` (may include store/update shape hints)
- `elements` (exact IDs for â€œDetect Variablesâ€ and â€œSave/Submitâ€)

### Goal
Fill the add-server form (one `ui_fill_state` call).

### Actions
1. Build the complete `addServerForm` update (all required fields at once):
   - `name` (snake_case internal identifier)
   - `display_name` (user-facing name)
   - `description`
   - `oauth_enabled` (true/false)
   - `config_template_json` (JSON string)
   - `variable_schema_json` (JSON string)
   - `ui_schema_json` (JSON string; MUST NOT be empty)
2. Create the JSON strings:
   - `config_template_json` MUST use placeholders like `{{api_key}}` inside `env`
   - Every placeholder MUST appear in:
     - `variable_schema_json.properties`
     - `ui_schema_json.sections[].field`
   - Mark secrets (API keys/tokens/passwords) with `"secret": true`
3. Execute the form fill:

```
TOOL_CALL: {"name": "ui_fill_state", "parameters": {"store_id": "mcp", "updates": {"addServerForm": {"name": "...", "display_name": "...", "description": "...", "config_template_json": "...", "variable_schema_json": "...", "ui_schema_json": "...", "oauth_enabled": false}}}}
```

4. Verify in the next context that `data.addServerForm` reflects your inputs (or shows validation errors).

### Minimal JSON skeletons (edit to match the selected server)

**config_template_json:**
```json
{
  "mcpServers": {
    "server_key": {
      "command": "npx",
      "args": ["-y", "@scope/package"],
      "env": {
        "API_KEY": "{{api_key}}"
      }
    }
  }
}
```

**variable_schema_json:**
```json
{
  "required": ["api_key"],
  "properties": {
    "api_key": { "type": "string", "title": "API Key", "secret": true }
  }
}
```

**ui_schema_json:**
```json
{
  "sections": [
    { "title": "API Key", "type": "password", "field": "api_key", "required": true }
  ]
}
```

### Transitions
- Form filled (no blocking validation errors) â†’ **DETECT_VARIABLES**
- Form fill failed / validation errors â†’ fix once and retry; if unclear, ask the user

---

## State: DETECT_VARIABLES

### Indicators
- Form is filled
- A â€œDetect Variablesâ€ affordance exists in `elements` (exact ID varies)

### Context Check
- `elements` (find a button that clearly corresponds to detecting/parsing variables)
- `data.addServerForm.config_template_json`

### Goal
Let the UI parse placeholders from the template (if supported).

### Actions
1. If a detect-variables button exists in `elements`, click it using the exact `id` from context.

Look in `elements` for `detect-variables-btn`:

```
TOOL_CALL: {"name": "ui_trigger_click", "parameters": {"element_id": "detect-variables-btn"}}
```

> **CRITICAL:** Use the EXACT `id` from `elements`. Never guess or construct IDs.

2. If no detect-variables affordance exists in `elements`, skip this state.

### Transitions
- Detection succeeded or skipped â†’ **SAVE**
- Detection failed â†’ return to **FORM_FILL** and fix template/schema mismatch

---

## State: SAVE

### Indicators
- Form is complete
- Variables are detected (or variable detection is not required on this UI)
- Ready to create the server template

### Context Check
- `elements` (save/submit button id)
- `data.addServerForm` (confirm values are present)

### Goal
Save the server template and verify success.

### Actions
1. Click the submit/save button using the exact `id` from `elements`.

Look in `elements` for `submit-server-btn`:

```
TOOL_CALL: {"name": "ui_trigger_click", "parameters": {"element_id": "submit-server-btn"}}
```

> **CRITICAL:** Use the EXACT `id` from `elements`. Never guess or construct IDs.
2. Verify result + context:
   - Success: the new server template appears in `data.servers` OR the UI exits the add-server flow with a success state
   - Failure: read the full error and return to **FORM_FILL** (name collision, invalid JSON, schema mismatch, missing required fields)

### Transitions
- Save successful (verified) â†’ **COMPLETE**
- Save failed â†’ **FORM_FILL**

---

## State: COMPLETE

### Indicators
- Server template has been created
- Context shows the new server in the list or on a confirmation view

### Actions
1. Confirm success and offer the next step (configure credentials using the configure-server flow / SOP).

---

## Common Pitfalls

1. **Empty `ui_schema_json`**: Users canâ€™t enter variables. Always define sections for every placeholder.
2. **Placeholder mismatch** between `config_template_json` and schemas: every `{{var}}` must exist in `variable_schema_json` and `ui_schema_json`.
3. **Secrets not marked** (`"secret": true`) for API keys/tokens/passwords.
4. **Proceeding without explicit selection** in **SELECTION**.
