---
description: "Operational Protocol: Viewing and live-editing an application. State-based guidance for helping users interact with rendered dashboards."
globs: []
alwaysApply: false
---

# Protocol: View Application

**Purpose:** Guide the user through viewing a rendered dashboard and making live edits to the manifest.

**Prerequisites:**
- User is on `/applications/{id}` (viewing a rendered dashboard)
- Application has loaded and is rendering
- User may want to interact with data, trigger actions, or make live edits

---

## State Machine Overview

```
ASSESS → INTERACT → [EDIT] → SAVE_CHANGES → COMPLETE
    ↑        │          │
    └────────┴──────────┘ (continuous interaction)
```

Note: Users may jump between INTERACT and EDIT states repeatedly.

---

## Planning

This protocol can be multi-step and stateful (especially when live-editing). When it is loaded, your **next assistant message must include a plan** before any tool call.

Output the plan as a single JSON object in a `json` code block, using:
- `goal`, `current_state`, `steps`, `decision_points`, `verification`
- step `status`: `todo` | `doing` | `done` | `blocked`

Example:

```json
{
  "goal": "Help the user view and (optionally) live-edit an application",
  "current_state": {
    "page": "/applications/…",
    "have_unsaved_changes": false
  },
  "steps": [
    {"id": "ASSESS", "status": "doing"},
    {"id": "INTERACT", "status": "todo"},
    {"id": "EDIT", "status": "todo"},
    {"id": "SAVE_CHANGES", "status": "todo"},
    {"id": "COMPLETE", "status": "todo"}
  ],
  "decision_points": [
    "Whether the user wants to only interact vs make manifest edits",
    "Confirm before saving if edits change behavior / workflow triggers"
  ],
  "verification": [
    "After each patch, check for new rendering errors",
    "After save/discard, unsaved-changes flag resets and UI reflects expected state"
  ]
}
```

Update this plan as you progress (mark statuses, add brief notes). If the user only wants to view, mark EDIT/SAVE_CHANGES as `done` with a short note (e.g., \"skipped\").

---

## State: ASSESS

### Indicators
- User has arrived at or is viewing the application dashboard
- Need to understand what's displayed and any issues
- Haven't yet determined what the user wants to do

### Context Check
```
page.full_path: Should start with "/applications/" (view page)
data.currentManifestJson: Editable manifest JSON string (for live patching)
data.renderingErrors: Rendering failures (if any)
data.dataSourceStates: Loading/error status for data sources (if any)
data.hasUnsavedManifestChanges: Unsaved edits flag (if present)
elements: Interactive controls on this page
actions: Semantic actions available (if present)
```

### Goal
Understand the dashboard state and identify any issues.

### Actions

**1. Check for errors:**
- Review `data.renderingErrors` (if present) for component failures
- Review `data.dataSourceStates` (if present) for data loading issues
- Note which elements/data sources are affected

**2. Understand current view:**
- Use `elements` and `actions` to see what can be clicked/triggered right now
- If the manifest/context provides tab/section info in `data`, identify the active tab/section

**3. If errors exist, report proactively:**

```
I notice some issues with the dashboard:

**Rendering Errors:**
- [element_id]: [error message]

**Data Source Issues:**
- [count] data sources errored

Would you like me to help diagnose and fix these?
```

### Transitions
- User asks to interact with data/actions → **INTERACT**
- User asks to modify the dashboard → **EDIT**
- User asks about errors → **ASSESS** (provide diagnosis)
- Dashboard is healthy, user exploring → **INTERACT**

---

## State: INTERACT

### Indicators
- User wants to use the dashboard (not edit it)
- May want to trigger actions, switch tabs, or understand data
- No live editing required

### Context Check
```
elements: Interactive controls available on this page
actions: Semantic actions available (if present)
data.currentManifest: May include tabs/layout summary (if present)
```

### Goal
Help the user interact with the dashboard.

### Actions

**For "Run the analysis" / Trigger an action:**

1. Find the relevant action in `actions` (if present) or the matching button in `elements`
2. Click the action button:

```
TOOL_CALL: {"name": "ui_trigger_click", "parameters": {"element_id": "[APPLICATION_ACTION_BUTTON_ID]"}}
```

3. For workflow actions: User will be redirected to workflow execution page

**For "Switch to X tab":**

1. Identify the correct tab control from `elements` (do not guess IDs)
2. Click the tab control:

```
TOOL_CALL: {"name": "ui_trigger_click", "parameters": {"element_id": "[APPLICATION_TAB_BUTTON_ID]"}}
```

3. Context will update to reflect the new active tab/section (in `data`, `elements`, and any tab indicators)

**For "Why is this empty/broken?":**

1. Check `data.renderingErrors` (if present) for the element
2. Check `data.dataSourceStates` (if present) for data issues
3. Explain clearly:

```
The [element name] is empty because the data source "[ds_id]" failed with error: "[error]".

This is likely due to [diagnosis]. Would you like me to fix it?
```

### Transitions
- User asks to fix/modify something → **EDIT**
- User continues interacting → Remain in **INTERACT**
- User is done → **COMPLETE**

---

## State: EDIT

### Indicators
- User wants to modify the dashboard
- Changes will be made to `currentManifestJson`
- Dashboard will re-render after edits

### Context Check
```
data.currentManifestJson: Must be present (editable JSON)
data.patchable_text_fields: Should include `currentManifestJson`
data.hasUnsavedManifestChanges: false (initially), then true after edits
```

### Goal
Apply live edits to the manifest using patching.

### Actions

**Key insight:** The manifest JSON (`currentManifestJson`) is patchable while viewing. When you apply a patch:
1. The JSON is updated locally
2. The manifest is **automatically saved to backend**
3. Data sources are reloaded with the new configuration
4. The dashboard re-renders with the results

**Auto-save behavior:** Patches are saved immediately during settlement. There's no need to manually click "Save Changes" after patching - it's done automatically. The settlement result shows whether the save succeeded and any data source errors.

**1. Explain what you're changing:**

```
I'll add a new metric card to show [description]. This will update the dashboard immediately.
```

**2. Apply patch using ui_patch_text:**

**CRITICAL: JSON Patching Format**

When patching JSON content, the `expected_text` and `replacement_text` must be properly formatted as JSON strings with:
- Newlines as `\n`
- Quotes escaped as `\"`
- Proper indentation preserved

**Correct format example:**

```
TOOL_CALL: {"name": "ui_patch_text", "parameters": {"store_id": "applications", "path": "currentManifestJson", "start_line": 109, "end_line": 132, "expected_text": "    \"weekly_events\": {\n      \"type\": \"mcp_tool\",\n      \"tool_name\": \"google_workspace__calendar_get_events\",\n      \"params\": {\n        \"time_min\": \"{{week_start}}\",\n        \"time_max\": \"{{week_end}}\"\n      }\n    },", "replacement_text": "    \"weekly_events\": {\n      \"type\": \"mcp_tool\",\n      \"tool_name\": \"google_workspace__calendar_get_events\",\n      \"params\": {\n        \"time_min\": \"{{week_start}}\",\n        \"time_max\": \"{{week_end}}\",\n        \"calendar_id\": \"primary\"\n      }\n    },"}}
```

**Key rules for JSON patching:**
- Keep the entire tool call as a single valid JSON object
- Use `\n` for newlines inside `expected_text` and `replacement_text`
- Use `\"` for quotes inside the text values
- Match indentation exactly (use spaces, not tabs)
- Include trailing commas if the original has them
- Verify brace balance in both `expected_text` and `replacement_text`

**3. Verify the change from settlement result:**
The patch tool result includes settlement info:
- `settlement.manifest_saved: true` - confirms save to backend succeeded
- `settlement.data_source_error_count` - number of data sources with errors
- `settlement.data_source_errors` - details of any errors

After settlement:
- Dashboard re-renders with changes
- Data sources reload and show actual results (errors or data)
- Check `data.renderingErrors` for component rendering issues

### Common Edit Operations

**Add a new component:**
1. Patch `ui_elements` to add component definition
2. Patch `layout` to include element reference
3. Patch `data_sources` if new data needed

**Fix a data source:**
1. Patch the specific data source configuration
2. May need to fix tool name, params, or transformations

---

## CRITICAL: Data Source Transformation Paths

**Understanding the difference between direct MCP tool calls and data source transformations is essential.**

### Direct MCP Tool Calls (Testing)

When you call an MCP tool directly (e.g., `google_workspace__calendar_get_events`), you receive the FULL response structure:

```json
{
  "result": {
    "raw_response": {
      "structuredContent": {
        "count": 10,
        "events": [...]
      }
    }
  }
}
```

### Data Source Transformations (Applications)

When data sources execute in applications, the system **unwraps the response** before applying transformations. Your transformations receive only the **actual data content**, not the wrapper structure:

```json
{
  "count": 10,
  "events": [...]
}
```

### Example: Correct vs Incorrect Paths

**WRONG (agent common mistake):**
```json
"transformations": [{
  "operation": "json_path_extract",
  "path": "result.raw_response.structuredContent.events"
}]
```

**CORRECT:**
```json
"transformations": [{
  "operation": "json_path_extract",
  "path": "events"
}]
```

### Reference: Working Efficacy App Data Sources

These are real, working transformation paths from a production application:

```json
// Simple SQL result (array of objects) - extract first row's field
"transformations": [{
  "operation": "json_path_extract",
  "path": "[0].total"
}]

// No transformation needed - data is already in correct format
"transformations": []
```

### How to Diagnose Transformation Errors

When you see errors like:
```
"Key 'result' not found in dict. Available keys: ['count', 'events']"
```

This tells you:
1. The transformation is looking for `result` but it doesn't exist
2. The actual data has keys `['count', 'events']` at the TOP level
3. **Fix:** Use `events` or `count` directly, not a nested path

### Key Rules

1. **Do NOT prefix with `result.raw_response.structuredContent`** - the application execution unwraps this for you
2. **Check the "Available keys" in error messages** - they show the actual structure you're working with
3. **SQL results are arrays** - use `[0].field_name` to get the first row
4. **Calendar/API results vary** - check what keys are actually available in errors

---

**Modify component props:**
1. Patch the specific element in `ui_elements`
2. Update relevant props

**Add an action:**
1. Patch `actions` section
2. Optionally add to Header component's actions prop

### Transitions
- Changes applied, check settlement result → If errors, remain in **EDIT** to fix
- All changes successful → Return to **INTERACT** (auto-saved)
- Multiple changes needed → Remain in **EDIT** for additional patches

**Note on auto-save:** Since patches are automatically saved during settlement, there's typically no "SAVE_CHANGES" state needed. However, if a manual edit is made without patching, the save/discard buttons are available.

---

## State: SAVE_CHANGES (Manual Save)

### Indicators
- Manual edits made outside of patching
- Unsaved changes flag is true (`data.hasUnsavedManifestChanges`)
- User wants to persist or discard changes

### Context Check
```
data.hasUnsavedManifestChanges: true (if present)
elements: Must include save/discard buttons
```

### Goal
Persist or discard manual changes.

### Actions

**To save changes:**

```
TOOL_CALL: {"name": "ui_trigger_click", "parameters": {"element_id": "save-manifest-btn"}}
```

**To discard changes:**

```
TOOL_CALL: {"name": "ui_trigger_click", "parameters": {"element_id": "discard-manifest-changes-btn"}}
```

**After save/discard:**
- Unsaved changes flag returns to false
- Dashboard reflects saved state (or reverts if discarded)

**Note:** When using `ui_patch_text`, changes are automatically saved during settlement. Manual save is only needed for edits made outside the patching flow.

### Transitions
- Changes saved → **COMPLETE**
- Changes discarded → **INTERACT**
- Save failed → Check error, return to **EDIT**

---

## State: COMPLETE

### Indicators
- User has finished interacting
- All changes saved (if any)
- Dashboard is in clean state

### Actions

**1. Summarize what was done:**

If edits were made:
```
✅ Dashboard updated!

**Changes:**
- [List of changes]

The application is now saved with your modifications.
```

If just viewing:
```
Is there anything else you'd like to do with this dashboard?
```

**2. Offer next actions:**
- Continue viewing → Return to **INTERACT**
- Edit more → Return to **EDIT**
- Go back to list → Navigate to `/applications`

---

---

## Element IDs Reference

| Element | ID | Purpose |
|---------|-----|---------|
| Back button | `back-to-applications-btn` | Return to applications list |
| Save button | `save-manifest-btn` | Save manifest changes |
| Discard button | `discard-manifest-changes-btn` | Discard unsaved changes |

---

## Common Pitfalls

1. **Patches auto-save**: Unlike manual edits, `ui_patch_text` automatically saves during settlement. Check `settlement.manifest_saved` in the result to confirm.

2. **Using wrong store path**: Use `currentManifestJson` on view page, not edit modal paths.

3. **Multiple unrelated changes**: Get user confirmation between major changes.

4. **Ignoring data source errors in settlement**: Check `settlement.data_source_errors` in patch result to see if fixes worked.

5. **Assuming manifest structure**: Rely on context data and patching, don't assume you know the full structure.

6. **Forgetting to explain changes**: Tell the user what you're changing before patching.

7. **Not checking settlement results**: After patching, check both `settlement.manifest_saved` and `settlement.data_source_errors` to verify success.

8. **Malformed JSON in patch tool calls**: When patching JSON content, ensure the tool call itself is valid JSON. Use `\n` for newlines and `\"` for quotes inside `expected_text` and `replacement_text` strings.

9. **Expecting immediate feedback loop resolution**: If multiple data sources have errors, you may need multiple patches. Each patch saves, reloads, and returns current state.
