---
description: "The authoritative syntax reference for the .wf.md file format. This rule defines the structure of the YAML frontmatter, step definitions, and variable resolution."
globs: []
alwaysApply: false
---
## Rule: Workflow Syntax Reference

This rule defines the precise syntax for a `.wf.md` file.

### 0.0 Golden Template (START HERE)

**Copy this template as your starting point. The `parameters:` block is REQUIRED if you use `${workflow.params.*}` anywhere.**

```markdown
---
title: "My Workflow Title"
description: "Brief description of what this workflow does"
version: "2.1"
autonomous: true
timeout: 600
parameters:
  my_input:
    type: string
    description: "Input parameter for this workflow"
    required: true
---

## Step 1: Fetch Data

**Tool:** `some_mcp_tool__action`
**Inputs:**
  param: "${workflow.params.my_input}"
**Outputs:**
  raw_data: any = result

## Step 2: Analyze with LLM

**Tool:** `llm`
**Inputs:**
  system_prompt: "You are a helpful assistant. Return JSON with your analysis."
  user_prompt: "Analyze: ${to_json(step1.raw_data)}"
  model: "anthropic/claude-sonnet-4-5"
**Outputs:**
  analysis: object = result
```

### 1.0 YAML Frontmatter

Every workflow must begin with a YAML frontmatter block enclosed by `---`.

| Key | Type | Required | Description |
| :--- | :--- | :--- | :--- |
| `title` | `string` | **Yes** | The human-readable name of the workflow. |
| `description`| `string` | No | A brief summary of the workflow's purpose. |
| `version` | `string` | **Yes** | Must be `"2.1"` or higher for workflows using container steps. |
| `autonomous`| `boolean`| **Yes** | Must be `true`. |
| `retry_limit`| `integer`| No | Default number of retries for failing steps. Default: `3`. |
| `timeout` | `integer`| No | Maximum execution time for the workflow in seconds. Default: `900`. |
| `tool_timeout`|`integer`| No | Default timeout in seconds for individual tool calls. Default: `60`. |
| `is_public` | `boolean` | No | Whether the workflow is publicly accessible. Default: `false`. |
| `parameters` | `object` | **Conditional** | **REQUIRED if you use `${workflow.params.*}`.** See Section 1.1. |

#### 1.1 Workflow Parameters (CRITICAL)

**⚠️ COMMON ERROR:** Using `${workflow.params.week_start}` without declaring `week_start` in the `parameters:` block will cause validation to fail.

If your workflow uses `${workflow.params.some_name}` in any step, you **MUST** declare that parameter in the frontmatter:

```yaml
parameters:
  param_name:
    type: string | integer | boolean | array | object
    description: "Human-readable description"
    required: true | false
    default: <optional default value>
```

**Example:**
```yaml
parameters:
  week_start:
    type: string
    description: "Start date of the week (YYYY-MM-DD)"
    required: true
  week_end:
    type: string
    description: "End date of the week (YYYY-MM-DD)"
    required: true
```

### 2.0 Step Structure

The body of the workflow consists of one or more steps, each beginning with a `## Step` header for top-level steps, or `### Step` for child steps within a container.

```markdown
## Step <number>: <Step Title>

A brief, natural language description of the step's objective.

**Tool:** `tool_name`
**Type:** `iterator` | `transform` | `branch`
**Config:**
  key: value
**Inputs:**
  key: value
**Outputs:**
  variable_name: type = extraction_path
```

**Directives:**

-   `## Step <number>: <Title>`: **(Required)** The step header. Top-level steps must be numbered sequentially starting from 1.
-   `**Tool:**`: **(Required for Standard Steps)** The unique identifier of the tool to execute (e.g., `github__get_pr_diff`, `llm`). This directive is **not allowed** in container steps (`iterator`, `branch`).
-   `**Type:**`: **(Required for Container & Transform Steps)** Declares the step's category: `iterator`, `branch`, or `transform`.
-   `**Config:**`: (Optional) A YAML block for step-specific execution settings (`timeout`, `retry`, `on_error`).
-   `**Inputs:**`: (Optional) A YAML block defining the parameters for the tool call.
-   `**Outputs:**`: (Optional) A list of output contracts (`variable: type = path`) that define the data this step produces. This directive is **not allowed** in `branch` containers.

#### 2.1 Iterator Step Syntax

Iterators loop over an array and execute child steps for each item.

```markdown
## Step 2: Process Items in Batches

**Type:** iterator

**Iterator:**
  source: ${step1.items_array}
  batch_size: 1

**Steps:**
  ### Step A: Process Single Item
  **Tool:** `some_tool`
  **Inputs:**
    item_data: ${iterator.item}
  **Outputs:**
    processed: any = result

**Iterator-Outputs:**
  all_results: array = collect(stepA.processed)
```

**Iterator-specific directives:**
- `**Iterator:**` - Configuration block with `source` (array to iterate) and optional `batch_size`
- `**Steps:**` - Contains child steps (use `### Step A:`, `### Step B:`, etc.)
- `**Iterator-Outputs:**` - Aggregation functions: `collect()`, `count()`, `sum()`, `first()`, `last()`

**Iterator variables:**
- `${iterator.item}` - Current item (when `batch_size: 1`)
- `${iterator.batch}` - Current batch array (when `batch_size > 1`)
- `${iterator.index}` - Current 0-based index

#### 2.2 Branch Step Syntax

Branches conditionally execute one of two paths.

```markdown
## Step 1: Check Condition

**Type:** branch

**Condition:** ${step0.some_array.length} > 0

**Then:**
  ### Step A: Handle Non-Empty Case
  **Tool:** `some_tool`
  **Outputs:**
    result: any = result

**Else:**
  ### Step B: Handle Empty Case
  **Tool:** `logger__log`
  **Inputs:**
    message: "No items to process"
  **Outputs:**
    log_result: any = result
```

**Branch-specific directives:**
- `**Condition:**` - Expression that evaluates to `true` or `false`
- `**Then:**` - Child steps executed if condition is true
- `**Else:**` - Child steps executed if condition is false

**⚠️ CRITICAL:** Branch steps have NO `**Outputs:**`. Data from inside a branch CANNOT be accessed outside.

### 3.0 Variable Syntax & Scope Resolution

Variables are used to pass data between steps and are referenced using the `${...}` syntax. The engine resolves variables by searching through a strict scope chain.

| Syntax | Scope | Description & Access Rules |
| :--- | :--- | :--- |
| `${iterator.item}` | **Iterator Local** | Accesses the current item being processed within an `iterator`'s child steps. |
| `${stepA.variable}` | **Container Local** | Accesses an output from a *previous child step* within the same `iterator` or `branch` block. |
| `${step<N>.variable}` | **Global** | Accesses a validated output from a previous top-level step (e.g., `${step1.user_id}`). |
| `${workflow.params.variable}` | **Global** | Accesses the initial context provided when the workflow execution begins. |

**Note:** Deep property access (e.g., `${step1.user.id}` or `${step1.items[0]}`) is **NOT** supported directly in variable references. You must use a **Transform** step with `json_path_extract` to extract nested values into a new variable.

#### **CRITICAL: Scope Isolation Rule**
> Outputs generated by child steps inside a container (`branch` or `iterator`) are **strictly local** to that container's execution block. They **CANNOT** be referenced by any step outside of it. An `iterator` can only expose data via its `**Iterator-Outputs:**` section. A `branch` cannot expose any data.

**Variable Filters:**
-   `${to_json(variable)}`: Serializes the variable into a compact JSON string.
-   `${sql_escape(variable)}`: Escapes single quotes within a string variable for safe use in SQL queries.
-   `${to_json_escaped(variable)}`: A combination of the above, creating a JSON string that is safe for SQL embedding.

### 4.0 Transform Step Operations

When a step is declared with `**Type:** transform`, its `**Transformations:**` block can contain a list of the following supported operations. They are executed sequentially on the input value.

| Operation | Required Parameters | Description |
| :--- | :--- | :--- |
| `regex_extract` | `pattern` (string), `group` (integer, optional) | Extracts a capturing group from a string using a regular expression. `group` defaults to `1`. |
| `json_parse` | (None) | Parses a string value into a JSON object or array. The workflow will fail if the string is not valid JSON. |
| `json_path_extract` | `path` (string) | Navigates to a specific field or element within a JSON object or array using dot notation and array indexing. Path syntax supports field access (`field.subfield`) and array indexing (`[0]`, `field[0]`, `[0].field`). The final extracted value becomes the new `current_value` for subsequent operations. |

**Common Transform Pattern Example:**

Processing database query results wrapped in untrusted-data tags:

```markdown
**Type:** transform
**Inputs:**
  data_to_clean: ${step1.raw_query_result}
**Transformations:**
  - operation: regex_extract
    pattern: '<untrusted-data[^>]+>\\s*(\\[.*\\]|\\{.*\\})\\s*</untrusted-data[^>]+>'
    group: 1
  - operation: json_parse
  - operation: json_path_extract
    path: "[0].report_data"
**Outputs:**
  clean_data: array = result
```

This pattern:
1. Extracts JSON from security wrapper using regex
2. Parses the JSON string into a structured object/array
3. Navigates to the specific field containing the data
4. Outputs the final extracted value as `result`
