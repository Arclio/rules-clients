---
description: "The authoritative syntax reference for the .wf.md file format. This rule defines the structure of the YAML frontmatter, step definitions, and variable resolution."
globs: []
alwaysApply: false
---
## Rule: Workflow Syntax Reference

This rule defines the precise syntax for a `.wf.md` file.

### 1.0 YAML Frontmatter

Every workflow must begin with a YAML frontmatter block enclosed by `---`.

| Key | Type | Required | Description |
| :--- | :--- | :--- | :--- |
| `title` | `string` | **Yes** | The human-readable name of the workflow. |
| `description`| `string` | No | A brief summary of the workflow's purpose. |
| `version` | `string` | **Yes** | Must be `"2.1"` or higher for workflows using container steps. |
| `autonomous`| `boolean`| **Yes** | Must be `true`. |
| `retry_limit`| `integer`| No | Default number of retries for failing steps. Default: `3`. |
| `timeout` | `integer`| No | Maximum execution time for the workflow in seconds. Default: `900`. |
| `tool_timeout`|`integer`| No | Default timeout in seconds for individual tool calls. Default: `60`. |
| `is_public` | `boolean` | No | Whether the workflow is publicly accessible. Default: `false`. |

### 2.0 Step Structure

The body of the workflow consists of one or more steps, each beginning with a `## Step` header for top-level steps, or `### Step` for child steps within a container.

```markdown
## Step <number>: <Step Title>

A brief, natural language description of the step's objective.

**Tool:** `tool_name`
**Type:** `iterator` | `transform` | `branch`
**Config:**
  key: value
**Inputs:**
  key: value
**Outputs:**
  variable_name: type = extraction_path
```

**Directives:**

-   `## Step <number>: <Title>`: **(Required)** The step header. Top-level steps must be numbered sequentially starting from 1.
-   `**Tool:**`: **(Required for Standard Steps)** The unique identifier of the tool to execute (e.g., `github__get_pr_diff`, `llm`). This directive is **not allowed** in container steps (`iterator`, `branch`).
-   `**Type:**`: **(Required for Container & Transform Steps)** Declares the step's category: `iterator`, `branch`, or `transform`.
-   `**Config:**`: (Optional) A YAML block for step-specific execution settings (`timeout`, `retry`, `on_error`).
-   `**Inputs:**`: (Optional) A YAML block defining the parameters for the tool call.
-   `**Outputs:**`: (Optional) A list of output contracts (`variable: type = path`) that define the data this step produces. This directive is **not allowed** in `branch` containers.

### 3.0 Variable Syntax & Scope Resolution

Variables are used to pass data between steps and are referenced using the `${...}` syntax. The engine resolves variables by searching through a strict scope chain.

| Syntax | Scope | Description & Access Rules |
| :--- | :--- | :--- |
| `${iterator.item}` | **Iterator Local** | Accesses the current item being processed within an `iterator`'s child steps. |
| `${stepA.variable}` | **Container Local** | Accesses an output from a *previous child step* within the same `iterator` or `branch` block. |
| `${step<N>.variable}` | **Global** | Accesses a validated output from a previous top-level step (e.g., `${step1.user_id}`). |
| `${workflow.params.variable}` | **Global** | Accesses the initial context provided when the workflow execution begins. |

#### **CRITICAL: Scope Isolation Rule**
> Outputs generated by child steps inside a container (`branch` or `iterator`) are **strictly local** to that container's execution block. They **CANNOT** be referenced by any step outside of it. An `iterator` can only expose data via its `**Iterator-Outputs:**` section. A `branch` cannot expose any data.

**Variable Filters:**
-   `${to_json(variable)}`: Serializes the variable into a compact JSON string.
-   `${sql_escape(variable)}`: Escapes single quotes within a string variable for safe use in SQL queries.
-   `${to_json_escaped(variable)}`: A combination of the above, creating a JSON string that is safe for SQL embedding.

### 4.0 Transform Step Operations

When a step is declared with `**Type:** transform`, its `**Transformations:**` block can contain a list of the following supported operations. They are executed sequentially on the input value.

| Operation | Required Parameters | Description |
| :--- | :--- | :--- |
| `regex_extract` | `pattern` (string), `group` (integer, optional) | Extracts a capturing group from a string using a regular expression. `group` defaults to `1`. |
| `json_parse` | (None) | Parses a string value into a JSON object or array. The workflow will fail if the string is not valid JSON. |
| `json_path_extract` | `path` (string) | Navigates to a specific field or element within a JSON object or array using dot notation and array indexing. Path syntax supports field access (`field.subfield`) and array indexing (`[0]`, `field[0]`, `[0].field`). The final extracted value becomes the new `current_value` for subsequent operations. |

**Common Transform Pattern Example:**

Processing database query results wrapped in untrusted-data tags:

```markdown
**Type:** transform
**Inputs:**
  data_to_clean: ${step1.raw_query_result}
**Transformations:**
  - operation: regex_extract
    pattern: '<untrusted-data[^>]+>\\s*(\\[.*\\]|\\{.*\\})\\s*</untrusted-data[^>]+>'
    group: 1
  - operation: json_parse
  - operation: json_path_extract
    path: "[0].report_data"
**Outputs:**
  clean_data: array = result
```

This pattern:
1. Extracts JSON from security wrapper using regex
2. Parses the JSON string into a structured object/array
3. Navigates to the specific field containing the data
4. Outputs the final extracted value as `result`
