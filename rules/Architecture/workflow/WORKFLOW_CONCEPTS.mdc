---
description: "Defines the fundamental concepts, purpose, and design principles of the Arclio Workflow Engine. This is the starting point for understanding how to build autonomous workflows."
globs: []
alwaysApply: false
---
## Rule: Workflow Engine Core Concepts

This rule establishes the foundational understanding of the Arclio Workflow Engine.

### 1.0 What is an Arclio Workflow?

An **Arclio Workflow** is an autonomous, multi-step process designed to accomplish complex goals without human intervention. It acts as an intelligent automation blueprint that transforms a high-level objective into a sequence of precise, executable actions.

Workflows are defined in a declarative text file format called **`.wf.md`**.

### 2.0 The `.wf.md` Blueprint

The **`.wf.md`** file is the single source of truth for a workflow's logic. It is a human-readable and machine-parseable document that consists of two primary sections:

1.  **Frontmatter:** A YAML block at the top of the file that defines the workflow's global metadata and configuration, such as its `title`, `version`, and default `timeout`.
2.  **Steps:** A sequence of actions written in Markdown that define the step-by-step logic of the process.

### 3.0 The Three Categories of Steps

Every workflow is composed of steps, which fall into one of two primary categories: **Standard Steps** that perform actions, and **Container Steps** that control execution flow.

#### 3.1 Standard Steps (Action Steps)
These are the fundamental building blocks that perform work. A standard step executes a single tool to achieve a specific outcome, such as calling an API, querying a database, or performing an AI-driven analysis.

#### 3.2 Container Steps (Flow Control)
These steps do not execute tools themselves. Instead, they manage the execution of a block of *child steps* nested within them. There are two types of container steps:

-   **Iterator Container (`Type: iterator`):** Executes its child steps repeatedly, once for each item in a source array. Its purpose is to perform batch processing and looping. It is the only container type that can aggregate results from its children into its own output.

-   **Branch Container (`Type: branch`):** Executes one of two blocks of child steps based on a condition. Its purpose is to introduce conditional logic and create different execution paths in the workflow.

### 4.0 The Four Pillars of Workflow Design

All workflows must be designed with the following principles in mind:

1.  **Predictable Data Flow through Contracts:** All data is managed through explicit `**Outputs:**` contracts. Each step must declare the data it produces, including a name, a static type, and an extraction path. This guarantees type safety and allows the engine to fail fast if a tool returns unexpected data.

2.  **Encapsulated Logic through Scope Isolation:** This is a critical principle for building reliable workflows.
    > Outputs generated by child steps inside a container (`branch` or `iterator`) are **strictly local** to that container. They cannot be referenced by any step outside of it.

    -   For an **`iterator`**, the only way to expose data is to explicitly aggregate it in the `**Iterator-Outputs:**` section.
    -   For a **`branch`**, there is no mechanism to expose data from its child steps to the outside. It is a fully self-contained execution path.

3.  **Tool Specialization:** Use the right tool for the job.
    -   Use **MCP Tools** for deterministic actions (e.g., fetching data from an API).
    -   Use the **`llm` Tool** for reasoning, analysis, and decision-making.
    -   Use the **`transform` Step** for simple, deterministic data cleaning.
    -   Use **Container Steps** (`iterator`, `branch`) for flow control.

4.  **Resilience by Design:** Workflows are designed to be robust. Each step can be configured with its own `retry` count and `on_error` strategy (`fail`, `continue`, or `skip`), allowing you to design for and gracefully handle potential failures.
